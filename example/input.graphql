# --------------------------------------------- fragments 
fragment profile on users {
  uid
  photoURL: photo_url
  displayName : display_name
  creationTime :created_at
  
}

# something to note about this query, the reaction returns as a list :/ 
fragment postFields on posts_view {
  creationTime: created_at
  lastUpdatedTime: updated_at
  postID: post_id
  postContent: post_content
  foroID: foro_id
  reactionsCount: reactions_count
  commentsCount: comments_count
  creator : creator {
   ...profile
  }
  # computed field basd on x-hasura-user-id
  reaction : user_reaction_to_post
}

# --------------------------------------------------------- MUTATIONS


mutation  updateProfilePhotoURL($uid: String!, $photo_url: String!) {
  update_users_by_pk(pk_columns: {uid: $uid}, _set: {photo_url: $photo_url}) {
   ...profile
  }
}

mutation updateProfileDisplayName($uid: String!, $display_name: String!) {
  update_users_by_pk(pk_columns: {uid: $uid}, _set: {display_name: $display_name}) {
   ...profile
  }
}



# role is not returned here and should be added on the client of the request is successful 
mutation createForo($display_name: String!, $photo_url: String!, $created_by: String!, $category: String = "others") {
  insert_foros_one(object: {display_name: $display_name, photo_url: $photo_url, created_by: $created_by, category: $category}) {
  category
  foro_id: foro_id
  displayName: display_name
  photoURL: photo_url
  createdBy: created_by
  creationTime: created_at
  lastUpdatedTime: updated_at
  }
}


mutation joinForo($uid: String!, $foroID: String!) {
  insert_memberships_one(object: {foro_id: $foroID, uid: $uid}) {
    foroID : foro_id
  }
}

mutation leaveForo($uid: String!, $foroID: String!) {
  delete_memberships(where: {foro_id: {_eq: $foroID}, uid: {_eq: $uid}}) {
    returning {
      foro_id
    }
  }
}


mutation updateForoPhotoURL($foroID: String!, $photo_url: String!) {
  update_foros_by_pk(pk_columns: {foro_id: $foroID}, _set: {photo_url: $photo_url}) {
   ...profile
  }
}

mutation updateForoDisplayName($foroID: String!, $display_name: String!) {
  update_foros_by_pk(pk_columns: {foro_id: $foroID}, _set: {display_name: $display_name}) {
   ...profile
  }
}


mutation createPost($post_content: String!, $created_by: String!, $foro_id: String!) {
  insert_posts_one(object: {post_content: $post_content, created_by: $created_by, foro_id: $foro_id}) {
    foroID : foro_id
    postID : post_id
    creationTime : created_at
    lastUpdatedTime : updated_at
    # some comment
    createdBy : created_by
  }
}


 # TODO: update post 


 # TODO: delete post 



mutation createComment($comment_content: String!, $created_by: String!, $foro_id: String!, $post_id: String!) {
  insert_comments_one(object: {comment_content: $comment_content, created_by: $created_by, foro_id: $foro_id, post_id: $post_id}) {
    comment_content
    comment_id
    created_at
    created_by
    foro_id
    post_id
    updated_at
  }
}


# TODO: update comment 



# TODO: delete comment 



# react to post  

mutation reactToPost($foro_id: String!, $post_id: String!, $reaction: String! = "like", $uid: String!) {
  insert_posts_reactions_one(object: {uid: $uid, foro_id: $foro_id, post_id: $post_id, reaction: $reaction}) {
    uid
    reaction_id
    reaction
    post_id
    foro_id
    created_at
  }
}

#  unreact to post  
mutation unReactToPost($foro_id: String!, $post_id: String!, $uid: String!) {
  delete_posts_reactions(where: {_and: {foro_id: {_eq: $foro_id}, post_id: {_eq: $post_id}, uid: {_eq: $uid}}}) {
    affected_rows
  }
}



# react to comment
mutation reactToComment($foro_id: String!, $post_id: String!, $comment_id: String!, $reaction: String! = "like", $uid: String!) {
  insert_comments_reactions_one(object: {uid: $uid, foro_id: $foro_id, post_id: $post_id, comment_id: $comment_id, reaction: $reaction}) {
    uid
    reaction_id
    reaction
    post_id
    foro_id
    created_at
  }
}

# unreact to comment   
mutation unReactToComment($foro_id: String!, $post_id: String!, $comment_id: String!, $uid: String!) {
  delete_comments_reactions(where: {_and: {foro_id: {_eq: $foro_id}, post_id: {_eq: $post_id}, comment_id: {_eq: $comment_id}, uid: {_eq: $uid}}}) {
    affected_rows
  }
}


# create conversation 
mutation createConversation($receiver_uid: String!, $sender_uid: String!) {
  insert_stub_create_conversation_one(object: {sender_uid: $sender_uid, receiver_uid: $receiver_uid}) {
    conversation_id
    receiver_uid
    sender_uid
  }
}


# send message
mutation sendMessage($content: String!, $conversation_id: String!, $sender_uid: String!, $parent_id: String = null,) {
  insert_messages_one(object: {content: $content, conversation_id: $conversation_id, sender_uid: $sender_uid, parent_id: $parent_id,}) {
    content
    conversation_id
    message_id
    parent_id
    sender_uid
  }
}





# --------------------------------------------------------- QUERIES 


query getJoinedForos($uid: String!) {
  foros_memberships(where: {uid: {_eq: $uid}}) {
  category
  foro_id: foro_id
  displayName: display_name
  photoURL: photo_url
  lastUpdatedTime: updated_at
  postsCount : posts_count
  }
}


# TODO: getForosForExplore



# TODO: currentUserDataStream


# -------- Convos and Messages


# get conversation ID 
query getConversationID($uid1: String!, $uid2: String!) {
  get_conversation_id(args: {uid1: $uid1, uid2: $uid2}) {
    conversationID : result
  }
}


# get convos -- postgres requires to order by the distinct field first, maybe find an efficient way to get latest convos (instead of creating an index for conversation_id plus created_at)
query getConvos($uid: String!) {
  messages: messages_view(distinct_on: conversation_id, where: {uid: {_eq: $uid}}, order_by: {conversation_id: asc, created_at: desc}) {
    conversationID: conversation_id
    messageContent: content
    creationTime: created_at
    isRead: is_read
    senderUID: sender_uid
  }
}



# get messages (or should we just query messages_status based on convo_id and uid)
query getMessages($conversation_id: String!, $uid: String!) {
  messages: messages_view(where: {_and: {conversation_id: {_eq: $conversation_id}, uid: {_eq: $uid}}}) {
    conversationID: conversation_id
    messageContent: content
    creationTime: created_at
    isRead: is_read
    senderUID: sender_uid
  }
}

# -------- Posts


query getNewestPosts($foroID: String!, $uid: String!) {
  posts: posts_view(where: {foro_id: {_eq: $foroID}}, order_by: {created_at: asc}) {
    ...postFields
  }
}

query getOldestPosts($foroID: String!, $uid: String!) {
  posts: posts_view(where: {foro_id: {_eq: $foroID}}, order_by: {created_at: desc}) {
    ...postFields
  }
}

query getMostLikedPosts($foroID: String!, $uid: String!) {
  posts: posts_view(where: {foro_id: {_eq: $foroID}}, order_by: {reactions_count: desc}) {
    ...postFields
  }
}

query getMostCommentedPots($foroID: String!, $uid: String!) {
  posts: posts_view(where: {foro_id: {_eq: $foroID}}, order_by: {comments_count: desc}) {
    ...postFields
  }
}



""" variable example:
{
  "foro_id": "######",
  "post_id": ""######",",
  "comment_content": "some content",
  "created_by": "uid"
}

 """


query getPostComments($foroID: String!, $postID: String!) {
  comments : comments_view(where: {_and: {foro_id: {_eq: $foroID}, post_id: {_eq: $postID}}}) {
    creationTime : created_at
    reactionsCount : reactions_count
    commentContent:comment_content
    creator {
      ...profile
    }
  }
}


# ---------- Profile



query getUserProfile($uid: String!) {
 
}

